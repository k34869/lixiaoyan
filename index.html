<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>送给李晓燕 - 3D 纸玫瑰</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #ffcad4;
    }

    /* 匹配背景粉色 */
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #d00030;
      font-family: 'Microsoft YaHei';
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="info">送给李晓燕</div>

  <script>
    const audio = new Audio('https://cdn.jsdmirror.com/gh/k34869/public@main/%E6%89%80%E5%BF%B5%E7%9A%86%E6%98%9F%E6%B2%B3%20.mp3')
    document.addEventListener('click', () => {
      audio.play();
    }, { once: true });
  </script>
  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffcad4); // 浅粉色背景

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 40, 145);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      // 启用阴影增加立体感
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // 光照设计：一个环境光 + 两个方向光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(10, 50, 20);
      dirLight.castShadow = true;
      scene.add(dirLight);

      // 核心功能：创建玫瑰组件
      createFancyRose();

      window.addEventListener('resize', onWindowResize);
    }

    function createFancyRose() {
      const roseGroup = new THREE.Group();

      // 1. 创建花瓣的函数
      // 采用弯曲的平面几何体
      const petalMaterial = new THREE.MeshStandardMaterial({
        color: 0xe61a3c,
        side: THREE.DoubleSide,
        roughness: 0.8,
        metalness: 0.1
      });

      // 花瓣层级数据：[花瓣数量, 层半径, 层高度, 缩放大小, 倾斜角度]
      const layers = [
        { count: 3, radius: 1, y: 0, scale: 4, rotX: 0.2 },  // 心部
        { count: 5, radius: 3, y: 2, scale: 6, rotX: 0.5 },  // 中层
        { count: 7, radius: 6, y: 4, scale: 8, rotX: 1.0 },  // 外层
        { count: 9, radius: 10, y: 6, scale: 10, rotX: 1.4 }   // 最外层舒展
      ];

      layers.forEach((layer, layerIdx) => {
        for (let i = 0; i < layer.count; i++) {
          // 使用简化的心形/泪滴形平面
          const shape = new THREE.Shape();
          shape.moveTo(0, 0);
          shape.bezierCurveTo(1.5, 1.5, 2, 4, 0, 6);
          shape.bezierCurveTo(-2, 4, -1.5, 1.5, 0, 0);

          const geometry = new THREE.ShapeGeometry(shape);

          // 修改顶点让花瓣变弯曲（"碗状"效果）
          const pos = geometry.attributes.position;
          for (let j = 0; j < pos.count; j++) {
            const x = pos.getX(j);
            const y = pos.getY(j);
            pos.setZ(j, (x * x + y * y) * 0.05); // 抛物面弯曲
          }
          geometry.computeVertexNormals();

          const petal = new THREE.Mesh(geometry, petalMaterial);

          // 布局花瓣
          const angle = (i / layer.count) * Math.PI * 2 + (layerIdx * 0.5); // 每层错开一点
          petal.position.x = Math.cos(angle) * layer.radius;
          petal.position.z = Math.sin(angle) * layer.radius;
          petal.position.y = layer.y;

          petal.scale.set(layer.scale, layer.scale, layer.scale);

          // 旋转让花瓣朝向中心并向外倾斜
          petal.lookAt(0, layer.y + 10, 0);
          petal.rotateX(layer.rotX);

          roseGroup.add(petal);
        }
      });

      // 2. 花托 (萼片 - 图片中花朵下方的绿尖)
      const sepalMat = new THREE.MeshStandardMaterial({ color: 0x4d7902 });
      for (let i = 0; i < 5; i++) {
        const sepalGeom = new THREE.ConeGeometry(2, 8, 3);
        const sepal = new THREE.Mesh(sepalGeom, sepalMat);
        const angle = (i / 5) * Math.PI * 2;
        sepal.position.set(Math.cos(angle) * 5, 5, Math.sin(angle) * 5);
        sepal.rotation.z = Math.PI / 2;
        sepal.lookAt(0, -5, 0);
        roseGroup.add(sepal);
      }

      // 3. 花茎
      const stemGeom = new THREE.CylinderGeometry(1, 1.2, 60, 12);
      const stemMat = new THREE.MeshStandardMaterial({ color: 0x3a5f0b });
      const stem = new THREE.Mesh(stemGeom, stemMat);
      stem.position.y = -25;
      roseGroup.add(stem);

      // 4. 叶子 (参考图片中宽阔且带有纹理的感觉)
      const leafShape = new THREE.Shape();
      leafShape.moveTo(0, 0);
      leafShape.bezierCurveTo(4, 2, 8, 8, 0, 12);
      leafShape.bezierCurveTo(-8, 8, -4, 2, 0, 0);
      const leafGeom = new THREE.ShapeGeometry(leafShape);
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x5a8a1b, side: THREE.DoubleSide });

      const leaf1 = new THREE.Mesh(leafGeom, leafMat);
      leaf1.position.set(1, -15, 0);
      leaf1.rotation.set(0.5, 0.2, -Math.PI / 4);
      leaf1.scale.set(1.5, 1.5, 1.5);
      roseGroup.add(leaf1);

      const leaf2 = leaf1.clone();
      leaf2.position.set(-1, -30, 0);
      leaf2.rotation.set(0.5, -0.2, Math.PI / 4 + 0.5);
      roseGroup.add(leaf2);

      scene.add(roseGroup);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>


</html>
